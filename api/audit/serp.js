/**
 * Enhanced SERP Analysis - Powered by ChatGPT-5 Brain
 * 
 * Provides deep competitor intelligence for both modes:
 * - Mode 1: Competitor content generation
 * - Mode 2: Self-audit and optimization
 */

import FirecrawlApp from '@mendable/firecrawl-js';
import { serpAnalysisBrain } from '../utils/ai-brain.js';

const firecrawl = new FirecrawlApp({ 
  apiKey: process.env.FIRECRAWL_API_KEY 
});

export default async function handler(req, res) {
  // Enable CORS
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const startTime = Date.now();

  try {
    const { keyword, targetUrl, limit = 10, mode = 'competitor' } = req.body;

    if (!keyword) {
      return res.status(400).json({ 
        error: 'Keyword is required' 
      });
    }

    console.log(`[SERP ANALYSIS] Keyword: "${keyword}" | Mode: ${mode}`);

    // Step 1: Get SERP results using Google search
    const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(keyword)}&num=${limit}`;
    
    console.log('[SERP] ðŸ“¡ Fetching SERP data...');
    const searchResult = await firecrawl.scrapeUrl(searchUrl, {
      formats: ['markdown', 'html'],
      onlyMainContent: false,
    });

    if (!searchResult.success) {
      return res.status(400).json({ 
        error: 'Failed to fetch SERP data' 
      });
    }

    // Step 2: Extract top URLs from search results
    const topUrls = extractSearchUrls(searchResult.markdown || '', limit);
    console.log(`[SERP] âœ… Found ${topUrls.length} competitor URLs`);

    if (topUrls.length === 0) {
      return res.status(400).json({
        error: 'No competitor URLs found in search results'
      });
    }

    // Step 3: Scrape each competitor page for detailed analysis
    console.log('[SERP] ðŸ•·ï¸ Scraping competitor pages...');
    const competitors = await scrapeCompetitors(topUrls, keyword);

    // Step 4: Analyze target URL if provided
    let targetAnalysis = null;
    if (targetUrl) {
      console.log(`[SERP] ðŸŽ¯ Analyzing target URL: ${targetUrl}`);
      targetAnalysis = await analyzeTargetUrl(targetUrl, keyword);
    }

    // Step 5: Perform gap analysis
    console.log('[SERP] ðŸ“Š Performing gap analysis...');
    const gapAnalysis = performGapAnalysis(competitors, targetAnalysis);

    // Step 6: Generate AI-powered strategic insights using ChatGPT-5
    console.log('[SERP] ðŸ§  Activating ChatGPT-5 Brain for strategic insights...');
    const aiInsights = await serpAnalysisBrain({
      keyword,
      competitors,
      targetAnalysis,
      gapAnalysis,
      mode
    });

    console.log(`[SERP] âœ… AI insights generated by ${aiInsights.model}`);

    // Step 7: Compile final report
    const executionTime = Date.now() - startTime;
    
    const report = {
      success: true,
      keyword: keyword,
      targetUrl: targetUrl || null,
      mode: mode,
      analyzedAt: new Date().toISOString(),
      
      // Summary metrics
      summary: {
        totalCompetitors: competitors.length,
        avgWordCount: Math.round(
          competitors.reduce((sum, c) => sum + c.wordCount, 0) / competitors.length
        ),
        avgHeadings: Math.round(
          competitors.reduce((sum, c) => sum + c.headings.total, 0) / competitors.length
        ),
        avgImages: Math.round(
          competitors.reduce((sum, c) => sum + c.images.total, 0) / competitors.length
        ),
        commonKeywords: gapAnalysis.commonKeywords.slice(0, 10),
      },
      
      // Detailed competitor data
      competitors: competitors.map(c => ({
        rank: c.rank,
        url: c.url,
        domain: c.domain,
        title: c.title,
        description: c.description,
        wordCount: c.wordCount,
        headings: c.headings,
        images: c.images,
        links: c.links,
        keywords: c.keywords.slice(0, 10), // Top 10 keywords only
        contentStructure: c.contentStructure,
        metaTags: c.metaTags,
      })),
      
      // Target comparison (if provided)
      targetAnalysis: targetAnalysis ? {
        url: targetAnalysis.url,
        domain: targetAnalysis.domain,
        title: targetAnalysis.title,
        wordCount: targetAnalysis.wordCount,
        headings: targetAnalysis.headings,
        images: targetAnalysis.images,
        links: targetAnalysis.links,
        keywords: targetAnalysis.keywords.slice(0, 10),
        metaTags: targetAnalysis.metaTags,
      } : null,
      
      // Gap analysis
      gapAnalysis: {
        commonKeywords: gapAnalysis.commonKeywords,
        missingKeywords: gapAnalysis.missingKeywords,
        contentGaps: gapAnalysis.contentGaps,
        averages: gapAnalysis.averages,
        targetComparison: gapAnalysis.targetComparison,
      },
      
      // AI-powered strategic insights (ChatGPT-5)
      insights: aiInsights.content,
      
      // AI metadata
      ai: {
        model: aiInsights.model,
        tokensUsed: aiInsights.usage,
        executionTime: aiInsights.executionTime,
      },
      
      // Performance metadata
      executionTime: `${(executionTime / 1000).toFixed(2)}s`,
    };

    console.log(`[SERP] ðŸŽ‰ COMPLETE - ${competitors.length} competitors analyzed in ${(executionTime / 1000).toFixed(2)}s`);
    return res.status(200).json(report);

  } catch (error) {
    const executionTime = Date.now() - startTime;
    console.error(`[SERP] âŒ FAILED: ${error.message} (${executionTime}ms)`);
    console.error('Stack trace:', error.stack);
    
    return res.status(500).json({ 
      error: 'SERP analysis failed',
      message: error.message,
      executionTime: `${(executionTime / 1000).toFixed(2)}s`,
    });
  }
}

// Extract URLs from Google search results
function extractSearchUrls(markdown, limit = 10) {
  const urls = [];
  const urlRegex = /https?:\/\/[^\s\)]+/g;
  const matches = markdown.match(urlRegex) || [];

  const seen = new Set();
  for (const url of matches) {
    if (urls.length >= limit) break;
    
    // Skip Google's own URLs and common non-content URLs
    if (
      url.includes('google.com') || 
      url.includes('gstatic.com') ||
      url.includes('youtube.com') ||
      url.includes('facebook.com') ||
      url.includes('twitter.com')
    ) continue;
    
    // Clean URL
    const cleanUrl = url.split('?')[0].split('#')[0];
    
    if (!seen.has(cleanUrl)) {
      seen.add(cleanUrl);
      urls.push(cleanUrl);
    }
  }

  return urls;
}

// Scrape competitor pages and extract key metrics
async function scrapeCompetitors(urls, keyword) {
  const competitors = [];
  
  for (let i = 0; i < urls.length; i++) {
    try {
      console.log(`  ðŸ“„ Scraping #${i + 1}: ${urls[i]}`);
      
      const result = await firecrawl.scrapeUrl(urls[i], {
        formats: ['markdown', 'html'],
        onlyMainContent: true,
        timeout: 15000,
      });

      if (!result.success) {
        console.log(`  âš ï¸ Failed to scrape: ${urls[i]}`);
        continue;
      }

      const content = result.markdown || '';
      const html = result.html || '';
      const metadata = result.metadata || {};

      // Extract metrics
      const analysis = {
        rank: i + 1,
        url: urls[i],
        domain: new URL(urls[i]).hostname,
        title: metadata.title || extractTitle(html) || 'No title',
        description: metadata.description || extractDescription(html) || '',
        wordCount: countWords(content),
        headings: extractHeadings(content),
        keywords: extractKeywords(content, keyword),
        images: extractImages(html),
        links: extractLinks(html, urls[i]),
        contentStructure: analyzeContentStructure(content),
        metaTags: {
          hasTitle: !!metadata.title,
          hasDescription: !!metadata.description,
          titleLength: (metadata.title || '').length,
          descriptionLength: (metadata.description || '').length,
        },
      };

      competitors.push(analysis);
      
    } catch (error) {
      console.log(`  âŒ Error scraping ${urls[i]}:`, error.message);
    }
  }

  return competitors;
}

// Analyze target URL
async function analyzeTargetUrl(url, keyword) {
  try {
    const result = await firecrawl.scrapeUrl(url, {
      formats: ['markdown', 'html'],
      onlyMainContent: true,
      timeout: 15000,
    });

    if (!result.success) {
      return null;
    }

    const content = result.markdown || '';
    const html = result.html || '';
    const metadata = result.metadata || {};

    return {
      url: url,
      domain: new URL(url).hostname,
      title: metadata.title || extractTitle(html) || 'No title',
      description: metadata.description || extractDescription(html) || '',
      wordCount: countWords(content),
      headings: extractHeadings(content),
      keywords: extractKeywords(content, keyword),
      images: extractImages(html),
      links: extractLinks(html, url),
      contentStructure: analyzeContentStructure(content),
      metaTags: {
        hasTitle: !!metadata.title,
        hasDescription: !!metadata.description,
        titleLength: (metadata.title || '').length,
        descriptionLength: (metadata.description || '').length,
      },
    };
  } catch (error) {
    console.error('Error analyzing target URL:', error);
    return null;
  }
}

// Perform gap analysis
function performGapAnalysis(competitors, targetAnalysis) {
  // Calculate averages
  const avgWordCount = competitors.reduce((sum, c) => sum + c.wordCount, 0) / competitors.length;
  const avgHeadings = competitors.reduce((sum, c) => sum + c.headings.total, 0) / competitors.length;
  const avgImages = competitors.reduce((sum, c) => sum + c.images.total, 0) / competitors.length;
  const avgInternalLinks = competitors.reduce((sum, c) => sum + c.links.internal, 0) / competitors.length;

  // Find common keywords (appearing in 50%+ of competitors)
  const keywordFrequency = {};
  competitors.forEach(c => {
    c.keywords.forEach(kw => {
      keywordFrequency[kw.keyword] = (keywordFrequency[kw.keyword] || 0) + 1;
    });
  });

  const threshold = Math.ceil(competitors.length * 0.5);
  const commonKeywords = Object.entries(keywordFrequency)
    .filter(([_, count]) => count >= threshold)
    .sort((a, b) => b[1] - a[1])
    .map(([keyword, count]) => ({
      keyword,
      frequency: count,
      percentage: Math.round((count / competitors.length) * 100)
    }));

  // Find missing keywords (if target URL provided)
  let missingKeywords = [];
  let targetComparison = null;

  if (targetAnalysis) {
    const targetKeywords = new Set(targetAnalysis.keywords.map(k => k.keyword.toLowerCase()));
    missingKeywords = commonKeywords
      .filter(ck => !targetKeywords.has(ck.keyword.toLowerCase()))
      .slice(0, 20);

    targetComparison = {
      wordCountDiff: targetAnalysis.wordCount - avgWordCount,
      wordCountPercentage: Math.round(((targetAnalysis.wordCount - avgWordCount) / avgWordCount) * 100),
      headingsDiff: targetAnalysis.headings.total - avgHeadings,
      imagesDiff: targetAnalysis.images.total - avgImages,
      internalLinksDiff: targetAnalysis.links.internal - avgInternalLinks,
    };
  }

  // Identify content gaps
  const contentGaps = [];
  
  if (!targetAnalysis || targetAnalysis.wordCount < avgWordCount * 0.8) {
    contentGaps.push({
      type: 'word_count',
      severity: 'high',
      message: `Content is ${Math.round(avgWordCount - (targetAnalysis?.wordCount || 0))} words shorter than average competitor`,
      recommendation: `Aim for ${Math.round(avgWordCount)} words or more`
    });
  }

  if (!targetAnalysis || targetAnalysis.headings.total < avgHeadings * 0.7) {
    contentGaps.push({
      type: 'headings',
      severity: 'medium',
      message: `Using fewer headings than competitors`,
      recommendation: `Add ${Math.round(avgHeadings - (targetAnalysis?.headings.total || 0))} more headings for better structure`
    });
  }

  if (!targetAnalysis || targetAnalysis.images.total < avgImages * 0.5) {
    contentGaps.push({
      type: 'images',
      severity: 'medium',
      message: `Fewer images than competitors`,
      recommendation: `Add ${Math.round(avgImages - (targetAnalysis?.images.total || 0))} more images`
    });
  }

  return {
    commonKeywords,
    missingKeywords,
    contentGaps,
    averages: {
      wordCount: Math.round(avgWordCount),
      headings: Math.round(avgHeadings),
      images: Math.round(avgImages),
      internalLinks: Math.round(avgInternalLinks),
    },
    targetComparison,
  };
}

// Helper functions
function countWords(text) {
  return text.trim().split(/\s+/).filter(word => word.length > 0).length;
}

function extractHeadings(markdown) {
  const h1 = (markdown.match(/^# .+$/gm) || []).length;
  const h2 = (markdown.match(/^## .+$/gm) || []).length;
  const h3 = (markdown.match(/^### .+$/gm) || []).length;
  const h4 = (markdown.match(/^#### .+$/gm) || []).length;
  const h5 = (markdown.match(/^##### .+$/gm) || []).length;
  const h6 = (markdown.match(/^###### .+$/gm) || []).length;

  return {
    h1, h2, h3, h4, h5, h6,
    total: h1 + h2 + h3 + h4 + h5 + h6
  };
}

function extractKeywords(content, targetKeyword) {
  const words = content.toLowerCase().split(/\s+/);
  const frequency = {};
  
  words.forEach(word => {
    const clean = word.replace(/[^a-z0-9]/g, '');
    if (clean.length > 3) {
      frequency[clean] = (frequency[clean] || 0) + 1;
    }
  });

  return Object.entries(frequency)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 50)
    .map(([keyword, count]) => ({
      keyword,
      count,
      density: ((count / words.length) * 100).toFixed(2)
    }));
}

function extractImages(html) {
  const imgMatches = html.match(/<img[^>]+>/g) || [];
  const withAlt = imgMatches.filter(img => img.includes('alt=')).length;
  
  return {
    total: imgMatches.length,
    withAlt: withAlt,
    withoutAlt: imgMatches.length - withAlt,
    altCoverage: imgMatches.length > 0 ? Math.round((withAlt / imgMatches.length) * 100) : 0
  };
}

function extractLinks(html, baseUrl) {
  const linkMatches = html.match(/<a[^>]+href=["']([^"']+)["'][^>]*>/g) || [];
  const domain = new URL(baseUrl).hostname;
  
  let internal = 0;
  let external = 0;
  
  linkMatches.forEach(link => {
    const hrefMatch = link.match(/href=["']([^"']+)["']/);
    if (hrefMatch) {
      const href = hrefMatch[1];
      if (href.includes(domain) || href.startsWith('/')) {
        internal++;
      } else if (href.startsWith('http')) {
        external++;
      }
    }
  });

  return {
    total: linkMatches.length,
    internal,
    external
  };
}

function extractTitle(html) {
  const match = html.match(/<title[^>]*>([^<]+)<\/title>/i);
  return match ? match[1].trim() : null;
}

function extractDescription(html) {
  const match = html.match(/<meta[^>]+name=["']description["'][^>]+content=["']([^"']+)["']/i);
  return match ? match[1].trim() : null;
}

function analyzeContentStructure(markdown) {
  const paragraphs = markdown.split('\n\n').filter(p => p.trim().length > 0).length;
  const lists = (markdown.match(/^[\*\-\+] .+$/gm) || []).length;
  const codeBlocks = (markdown.match(/```[\s\S]*?```/g) || []).length;
  const blockquotes = (markdown.match(/^> .+$/gm) || []).length;

  return {
    paragraphs,
    lists,
    codeBlocks,
    blockquotes
  };
}
