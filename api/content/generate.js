/**
 * Mode 1: Competitor Content Generator
 * Powered by ChatGPT-5 Brain - The world's smartest content generation
 */

import { contentGenerationBrain, getUsageStats } from '../utils/ai-brain.js';

export default async function handler(req, res) {
  // Enable CORS
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  if (req.method !== 'POST') {
    return res.status(405).json({ 
      error: 'Method not allowed',
      message: 'This endpoint only accepts POST requests' 
    });
  }

  const startTime = Date.now();

  try {
    const { keyword, serpData, targetUrl, style = 'professional' } = req.body;

    // Validate inputs
    if (!keyword) {
      return res.status(400).json({ 
        error: 'Keyword is required',
        message: 'Please provide a target keyword' 
      });
    }

    if (!serpData || !serpData.competitors || serpData.competitors.length === 0) {
      return res.status(400).json({ 
        error: 'SERP data is required',
        message: 'Please provide competitor analysis data' 
      });
    }

    console.log(`[MODE 1 - CONTENT GENERATION] Keyword: "${keyword}"`);
    console.log(`[MODE 1] Analyzing ${serpData.competitors.length} competitors...`);

    // Extract competitor insights
    const competitorInsights = extractCompetitorInsights(serpData);
    
    console.log('[MODE 1] ðŸ§  Activating ChatGPT-5 Brain for content generation...');
    
    // Generate content using ChatGPT-5 Brain
    const aiResponse = await contentGenerationBrain({
      keyword,
      competitorInsights,
      commonKeywords: serpData.commonKeywords || [],
      style
    });

    const generatedContent = aiResponse.content;
    const aiModel = aiResponse.model;
    const aiUsage = aiResponse.usage;

    console.log(`[MODE 1] âœ… Content generated by ${aiModel}`);
    console.log(`[MODE 1] ðŸ“Š ${generatedContent.wordCount} words, Score: ${generatedContent.estimatedScore}/100`);

    // Optimize content structure
    const optimizedContent = optimizeContentStructure(generatedContent, serpData);

    // Generate image suggestions
    const imageSuggestions = generateImageSuggestions(optimizedContent, keyword);

    const executionTime = Date.now() - startTime;
    const usageStats = getUsageStats();

    const response = {
      success: true,
      data: {
        keyword,
        targetUrl: targetUrl || null,
        
        // Generated content
        content: {
          title: optimizedContent.title,
          metaDescription: optimizedContent.metaDescription,
          body: optimizedContent.body,
          wordCount: optimizedContent.wordCount,
          readingTime: Math.ceil(optimizedContent.wordCount / 200),
        },

        // SEO metrics
        seo: {
          estimatedScore: optimizedContent.estimatedScore,
          keywordDensity: calculateKeywordDensity(optimizedContent.body, keyword),
          headingCount: countHeadings(optimizedContent.body),
          internalLinkSuggestions: optimizedContent.internalLinks || [],
          eatSignals: optimizedContent.eatSignals || [],
        },

        // Improvements over competitors
        improvements: {
          averageCompetitorWordCount: competitorInsights.avgWordCount,
          yourWordCount: optimizedContent.wordCount,
          wordCountDifference: optimizedContent.wordCount - competitorInsights.avgWordCount,
          keywordsCovered: optimizedContent.keywordsCovered || [],
          uniqueAngles: optimizedContent.uniqueAngles || [],
        },

        // Image suggestions
        images: imageSuggestions,

        // Export options
        exports: {
          html: convertToHTML(optimizedContent),
          markdown: optimizedContent.body,
          wordpress: generateWordPressExport(optimizedContent),
        },

        // AI Brain metadata
        ai: {
          model: aiModel,
          tokensUsed: aiUsage,
          totalCost: usageStats.totalCost,
          averageCostPerRequest: usageStats.averageCostPerRequest,
        },

        // Metadata
        generatedAt: new Date().toISOString(),
        executionTime: `${(executionTime / 1000).toFixed(2)}s`,
      }
    };

    console.log(`[MODE 1] ðŸŽ‰ COMPLETE - ${optimizedContent.wordCount} words in ${(executionTime / 1000).toFixed(2)}s`);
    console.log(`[MODE 1] ðŸ’° Cost: $${usageStats.totalCost.toFixed(4)}`);

    return res.status(200).json(response);

  } catch (error) {
    const executionTime = Date.now() - startTime;
    console.error(`[MODE 1] âŒ FAILED: ${error.message} (${executionTime}ms)`);
    console.error('Stack trace:', error.stack);
    
    return res.status(500).json({ 
      error: 'Content generation failed',
      message: error.message || 'An unexpected error occurred',
      details: 'The AI brain encountered an error. Please try again or contact support.',
      executionTime: `${(executionTime / 1000).toFixed(2)}s`,
    });
  }
}

/**
 * Extract insights from competitor data
 */
function extractCompetitorInsights(serpData) {
  const competitors = serpData.competitors || [];
  
  const totalWordCount = competitors.reduce((sum, c) => sum + (c.wordCount || 0), 0);
  const avgWordCount = Math.round(totalWordCount / competitors.length);
  
  const totalHeadings = competitors.reduce((sum, c) => sum + (c.headings || 0), 0);
  const avgHeadings = Math.round(totalHeadings / competitors.length);

  const allKeywords = competitors.flatMap(c => c.keywords || []);
  const keywordFrequency = {};
  allKeywords.forEach(kw => {
    keywordFrequency[kw] = (keywordFrequency[kw] || 0) + 1;
  });

  return {
    avgWordCount,
    avgHeadings,
    topKeywords: Object.entries(keywordFrequency)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 20)
      .map(([kw]) => kw),
    competitorCount: competitors.length,
  };
}

/**
 * Optimize content structure
 */
function optimizeContentStructure(content, serpData) {
  // Add missing keywords if any
  const missingKeywords = serpData.missingKeywords || [];
  if (missingKeywords.length > 0) {
    content.keywordsCovered = [
      ...(content.keywordsCovered || []),
      ...missingKeywords.slice(0, 5)
    ];
  }

  // Ensure minimum word count
  if (content.wordCount < 1500) {
    content.estimatedScore = Math.max(content.estimatedScore - 10, 0);
  }

  // Boost score for E-E-A-T signals
  if (content.eatSignals && content.eatSignals.length >= 3) {
    content.estimatedScore = Math.min(content.estimatedScore + 5, 100);
  }

  return content;
}

/**
 * Generate image suggestions
 */
function generateImageSuggestions(content, keyword) {
  const suggestions = [];
  
  // Hero image
  suggestions.push({
    type: 'hero',
    prompt: `Professional hero image for article about ${keyword}`,
    placement: 'top',
    altText: `${keyword} - comprehensive guide`
  });

  // Section images based on headings
  const headings = content.body.match(/^##\s+(.+)$/gm) || [];
  headings.slice(0, 3).forEach((heading, index) => {
    const cleanHeading = heading.replace(/^##\s+/, '');
    suggestions.push({
      type: 'section',
      prompt: `Illustrative image for section: ${cleanHeading}`,
      placement: `section-${index + 1}`,
      altText: cleanHeading
    });
  });

  // Infographic suggestion
  if (content.wordCount > 2000) {
    suggestions.push({
      type: 'infographic',
      prompt: `Infographic summarizing key points about ${keyword}`,
      placement: 'middle',
      altText: `${keyword} infographic - key statistics and insights`
    });
  }

  return suggestions;
}

/**
 * Calculate keyword density
 */
function calculateKeywordDensity(text, keyword) {
  const words = text.toLowerCase().split(/\s+/);
  const keywordWords = keyword.toLowerCase().split(/\s+/);
  
  let count = 0;
  for (let i = 0; i <= words.length - keywordWords.length; i++) {
    const phrase = words.slice(i, i + keywordWords.length).join(' ');
    if (phrase === keyword.toLowerCase()) {
      count++;
    }
  }
  
  const density = (count / words.length) * 100;
  return {
    count,
    density: density.toFixed(2),
    optimal: density >= 0.5 && density <= 2.5
  };
}

/**
 * Count headings in markdown
 */
function countHeadings(markdown) {
  const h2Count = (markdown.match(/^##\s+/gm) || []).length;
  const h3Count = (markdown.match(/^###\s+/gm) || []).length;
  
  return {
    total: h2Count + h3Count,
    h2: h2Count,
    h3: h3Count
  };
}

/**
 * Convert markdown to HTML
 */
function convertToHTML(content) {
  let html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${content.title}</title>
  <meta name="description" content="${content.metaDescription}">
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      line-height: 1.6;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      color: #333;
    }
    h1 { font-size: 2.5em; margin-bottom: 0.5em; }
    h2 { font-size: 1.8em; margin-top: 1.5em; border-bottom: 2px solid #eee; padding-bottom: 0.3em; }
    h3 { font-size: 1.4em; margin-top: 1.2em; }
    p { margin: 1em 0; }
    strong { font-weight: 600; }
    em { font-style: italic; }
    ul, ol { margin: 1em 0; padding-left: 2em; }
    li { margin: 0.5em 0; }
  </style>
</head>
<body>
  <article>
    <h1>${content.title}</h1>
`;

  // Convert markdown to HTML (basic conversion)
  let bodyHtml = content.body
    .replace(/^## (.+)$/gm, '<h2>$1</h2>')
    .replace(/^### (.+)$/gm, '<h3>$1</h3>')
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.+?)\*/g, '<em>$1</em>')
    .replace(/\n\n/g, '</p><p>')
    .replace(/^- (.+)$/gm, '<li>$1</li>')
    .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');

  html += `    <p>${bodyHtml}</p>
  </article>
</body>
</html>`;

  return html;
}

/**
 * Generate WordPress export format
 */
function generateWordPressExport(content) {
  return {
    title: content.title,
    content: content.body,
    excerpt: content.metaDescription,
    status: 'draft',
    meta: {
      _yoast_wpseo_title: content.title,
      _yoast_wpseo_metadesc: content.metaDescription,
    }
  };
}
